# 计组整理



## 第一章 绪论



### 冯诺依曼结构

> 任何要计算机完成的工作都要先编写成程序



**冯诺依曼**结构计算机最重要的思想：

- **存储程序**工作方式



计算机层次结构：

1. 高级编程语言
2. 汇编语言
3. 二进制代码（机器语言）
4. **ISA** （硬件抽象层）
5. 硬件结构
6. 逻辑电路



软件抽象层和硬件设计抽象层通过**ISA**进行交互，它是**软件和硬件交互的接口**



### 抽象

> 注重功能而无需知道细节



**抽象**是计算机科学当中最为重要的概念之一，是**实现分层的一种方式**

例如：

- **文件**是对**IO设备**的抽象
- **虚拟内存**是对**程序存储器**的抽象
- **进程**是对**一个正在运行的程序**的抽象
- **虚拟机**（不是VMWare里面那种）是对**整个计算机**的抽象



### 并发和并行

它们都形容了计算机同时处理多个任务，不过：



**并发**：逻辑上的并行（伪并行），实际上是**交替执行**，并没有真正地一次处理多条指令

**并行**：完全意义上的并行，同时处理多条指令



## 第二章 数制与运算

### 原码，补码和反码

一个数的**原码**就是直接用二进制表示

一个**正数的反码**是**其本身**，负数的反码是指**除符号位**外**全部取反**

一个**正数的补码**就是**它本身**，一个**负数的补码**是其**反码+1**

$[10000]_补=[11111] + 1=[00000]$

$[00000]_补=[00000]$

补码的出现，保证了0的唯一性，避免了+0，-0的混乱



$[X + Y]_补=[X]_补+[Y]_补$

$[X-Y]_补=[X]_补+[-Y]_补$



因此，计算机中**没有减法器**，减法可以直接通过加法器来实现



### 将十进制转化为二进制

例如$(62.625)_{10}$

先转化整数部分：

$62 \div 2 = 31 \dots 0$

$31 \div 2 = 15 \dots 1$

$15 \div 2 = 7 \dots 1$

$7 \div 2 = 3 \dots 1$

$3 \div 2 = 1 \dots 1$

$1 \div 2 = 0 \dots 1$

所以整数部分$(62)_{10} = (111110)_2$



**小数部分**：

$0.625 \times 2 = 1.25 = 1 + 0.25$

$0.25 \times 2 = 0.5 = 0 + 0.5$

$0.5 \times 2 = 1.0 = 1 + 0$

所以小数部分是$(101)_2$



因此，$(62.625)_{10} = (111110.101)_2$



### 浮点数的表示和运算

浮点数分为**阶码和尾数**两个部分

| 阶符         | 阶码值                   | 数符         | 尾数值           |
| ------------ | ------------------------ | ------------ | ---------------- |
| 表示阶的符号 | 表示阶（数量级）的绝对值 | 表示值的符号 | 表示真值的绝对值 |

注意，在二进制下，这个**数量级**指的是$2$的次方

在实际的表示下（IEEE 754）

- float

| 数符        | 阶E                     | 尾数M        |
| ----------- | ----------------------- | ------------ |
| 1位表示符号 | 8位，表示阶（-127偏移） | 23位，表示值 |



- double

| 数符        | 阶E                       | 尾数M        |
| ----------- | ------------------------- | ------------ |
| 1位表示符号 | 11位，表示阶（-1023偏移） | 52位，表示值 |



对于n位阶码，其偏移量为$2^{n-1} - 1$

**尾数的前一位一定默认是1**，在计算机中不表示出来，但是实际上是默认了有

因此，1的float表示就是：

数符：0，实际阶二进制：127，尾数0

表示为 

0 01111111 00000000000000000000000



可以通过这段程序验证：

```C
#include <stdio.h>

void ShowBinCodeI(int target) {
    unsigned int reader = 0x80000000;
    while(reader > 0) {
        putchar(reader & target ? '1' : '0');
        reader >>= 1;
    }
    return;
}

const unsigned SHOW_HELP = 0x00000001;
const unsigned NONE = 0x00000000;

void ShowBinCodeF(const float target, unsigned int mask) {
    unsigned int reader = 0x80000000;
    const unsigned source = *((const unsigned*)(&target)); 
    if(mask & SHOW_HELP) {
        printf("原型: ");
    }
    while(reader > 0) {
        putchar(reader & source ? '1' : '0');
        reader >>= 1;
    }
    putchar('\n');
    reader = 0x80000000;
    if(mask & SHOW_HELP) {
        printf("====分析====\n");
        printf("数符：");
        putchar(reader & source ? '1' : '0');
        putchar('\n');
        printf("阶：");
        for(int i = 0; i < 8; i++) {
            reader >>= 1;
            putchar(reader & source ? '1' : '0');
        }
        putchar('\n');
        printf("尾数：");
        for(int i = 0; i < 23; i++) {
            reader >>= 1;
            putchar(reader & source ? '1' : '0');
        }
        putchar('\n');
    }
    return;
}

int main() {
    float a = 1.0f;
    ShowBinCodeF(a, SHOW_HELP);
}
```



使用 **非规格化浮点数** 可以填补0到浮点数最小数之间的空白

（由于规格化下，默认有一个1在小数点左边，导致最小数和0之间有很大一片空白）

非规格化浮点数下，$E（阶）=0，M（尾数） \ne 0$，去掉了一定卡在最小数和0之间的一个1，那么就使得精度更高



IEEE约定下：

| E阶               | M尾数     | 浮点数类型   |
| ----------------- | --------- | ------------ |
| $1 \le E \le 254$ | $M \ne 0$ | 规范浮点数   |
| $E=0$             | $M = 0$   | 0            |
| $E=0$             | $M \ne 0$ | 非规范浮点数 |
| $E=255$           | $M = 0$   | 无穷大       |
| $E=255$           | $M \ne 0$ | $NaN$        |



### 布尔代数简介

**重叠律**

> 相同的内容可以互相吸收

$A + A = A \ \ \ A \circ A = A$



**吸收律**

> 或下，宽泛的条件可以吸收严格的条件
>
> 且下，严格的条件可以吸收宽泛的条件

$A + A \circ B = A\ \ \ A \circ (A + B) = A$

$A + \overline{A}B = A + B$



**还原律**

> 双重否定为肯定

$\overline{\overline{A}}=A$



**反演律**（德摩根律）

> 或之非等于非之且，且之非等于非之或

$\overline{A + B} = \overline{A} \circ \overline{B}$



**包含律**

> 被包含者为多余

$A \circ B + \overline{A} \circ C + B \circ C = A \circ B + \overline{A} \circ C$

$(A + B) \circ (\overline{A} + C) \circ (B +C) = (A + B) \circ (\overline{A} + C)$



**反演定理**

将原函数$F$当中且或互换，1,0常数互换，**非与原互换**，则新函数为原函数反函数$\overline{F}$



**对偶定理**

将原函数$F$当中且或互换，1,0常数互换，获得的新函数是原函数的对偶式，记为$F^*$或者$F'$，如果$F = G$，则$F'=G'$



**无法**直接建立$F$和其对偶式的关系



### 逻辑函数

标准表达式：

- 最小项表达式：积之和式，**即列举所有的为真情况**
- 最大项表达式：和之积式，**即列举所有的为假情况并予以否定**



**相邻最小项**：除了一个变量互为反变量，其余变量都相同的两个最小项

**具有相邻性的两个最小项的和**可以**合并**为一个乘积项
$$
\overline{A}\overline{B}\overline{C} + \overline{A} \overline{B} C = \overline{A} \overline{B}
$$
最小项表达式：

将非和原型分别用0和1表示形成二进制数，写成它们的和

例如：

$F=\overline{A}BC + A\overline{B}C$

$= m_3 + m_5$

$=\sum m(3, 5)$



